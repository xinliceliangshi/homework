/*1.概述
举例而言，对于 1 ~ 4 的一个全排列 [1, 2, 3, 4] 和 [4, 3, 2, 1]，我们知道，从字典序而言，前者是该全排列集的第一个，后者是该集的最后一个。那么，所谓康托展开，即给定一个 n nn 位数的全排列，我们可以根据康托展开公式确定其应当是字典序中的第“几”个全排列。
由于康托展开计算的是某个全排列方式在该全排列集合中的字典序(或者说是排名)，其映射关系唯一且单调，故该映射关系是可逆的。即，我们给定一个全排列的所有字符，以及某个字典序号，我们可以利用逆康托展开得到相应的那个全排列。
————————————————
版权声明：本文为CSDN博主「ajaxlt」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/ajaxlt/article/details/86544074
*/
/*
2.康托展开
给定一个全排列，计算其字典序。直观起见，我们举例[2, 3, 4, 1]来说明康托展开的运作步骤：
命所求字典序为 r a n k = 0 rank = 0rank=0

第 1 位是 2， 那么以 1 打头的所有全排列一定排在这个全排列之前，那么以 1 打头的全排列有 (3!) = 6种，r a n k = r a n k + 1 ∗ 3 ! = 6 rank = rank + 1*3! = 6rank=rank+1∗3!=6。
第 2 位是 3，那么以 1 与 2 作为第二位的所有全排列一定在这个圈排列之前。不过我们已经让 2 打头了，因此不需要再考虑 2 占第二位的情况，只需要计算 1 占第二位的情况。r a n k = r a n k + 1 ∗ 2 ! = 8 rank = rank + 1 * 2! = 8rank=rank+1∗2!=8。
第三位是 4，同时，我们计算以 1 占第三位的所有情况。r a n k = r a n k + 1 ∗ 1 ! = 9 rank = rank + 1 * 1! = 9rank=rank+1∗1!=9。
最后一位，是不需要判定的，因为前 n − 1 n - 1n−1 位给定后，第 n nn 位自定。当然，为了也适应前面推导，可以记 r a n k = r a n k + 0 ∗ 0 ! = 9 rank = rank + 0 * 0! = 9rank=rank+0∗0!=9。
由是，排在 [2, 3, 4, 1] 之前的全排列共有 9 个，那么 [2, 3, 4, 1] 应当是第 10 个全排列。总结康托展开公式为：
表示原排列中，排在下标 i ii 后面的，比下标 i ii 的字符还小的字符个数。当然，如果排名是从 1 开始的话，最终结果应当再 + 1。

C++ 实现
————————————————
版权声明：本文为CSDN博主「ajaxlt」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/ajaxlt/article/details/86544074
*/

//对前 10 个自然数(0 ~ 9)的阶乘存入表
//以免去对其额外的计算
const int fact[10] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};
/**
 * @brief 康拓展开
 *
 * @param[in] permutation 输入的一个全排列
 * @param[out] num 输入的康拓映射，即是第几个全排列
 */
int contor(const vector<int>& permutation) {
    int num = 0;
    int len = permutation.size();
    for (int i = 0; i < len; ++i) {
        int cnt = 0; // 在 i 之后，比 i 还小的有几个
        for (int j = i + 1; j < len; ++j)
            if (permutation[i] > permutation[j]) ++cnt;
        num += cnt * fact[len - i - 1];
    }
    return num + 1;
}


